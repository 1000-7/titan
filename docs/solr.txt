[[solr]]
Solr
----


[quote,'http://lucene.apache.org/solr/[Solr Homepage]']
Solr is the popular, blazing fast open source enterprise search platform from the Apache Lucene project. Solr is a standalone enterprise search server with a REST-like API. Solr is highly reliable, scalable and fault tolerant, providing distributed indexing, replication and load-balanced querying, automated failover and recovery, centralized configuration and more.

Titan supports http://lucene.apache.org/solr/[Solr] as an index backend.  Here are some of the Solr features supported by Titan:

* *Full-Text*: Supports all `Text` predicates to search for text properties that matches a given word, prefix or regular expression.
* *Geo*: Supports the `Geo.WITHIN` condition to search for points that fall within a given circle. Only supports points for indexing and circles for querying.
* *Numeric Range*: Supports all numeric comparisons in `Compare`.
* *TTL*: Supports automatically expiring indexed elements.

Please see <<version-compat>> for details on what versions of Solr will work with Titan.

Solr Configuration Overview
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Connecting to Solr
^^^^^^^^^^^^^^^^^^

Titan supports two different modes of connecting to a running Solr instance or cluster of instances: SolrCloud and HTTP. The desired connection mode is configured via the parameter `mode` which must be set to either `http` or `cloud`, the latter being the default value.

Connecting to SolrCloud
+++++++++++++++++++++++

When connecting to a SolrCloud enabled cluster by setting the `mode` equal to `cloud`, the Zookeeper URL (and optionally port) must be specified so that Titan can discover and interact with the Solr cluster.

[source,properties]
----
index.search.backend=solr
index.search.solr.mode=cloud
index.search.solr.zookeeper-url=localhost:2181
----

A number of additional configuration options pertaining to the creation of new collections (which is only supported in SolrCloud operation mode) can be configured to control sharding behavior among other things. Refer to the <<titan-config-ref>> for a complete listing of those options.


Connecting via HTTP
+++++++++++++++++++

When connecting to Solr via HTTP by setting the `mode` equal to `http` a single or list of URLs for the Solr instances must be provided.

[source,properties]
----
index.search.backend=solr
index.search.solr.mode=http
index.search.solr.http-urls=http://localhost:8983/solr
----

Additional configuration options for controlling the maximum number of connections, connection timeout and transmission compression are available for the HTTP mode. Refer to the <<titan-config-ref>> for a complete listing of those options.

Solr Collections
^^^^^^^^^^^^^^^^

Collection Initialization
+++++++++++++++++++++++++

It is required that a collection is initialized in Solr before it can be used by Titan. Initialization refers to definition of a schema (e.g. provided as a `schema.xml` file), and other configurations for a particular collection. When a <<index-mixed>> is defined, a unique name is assigned to that index. For each such index backed by a Solr indexing backend, a collection with that same name must be initialized in Solr before the index can be used in Titan.

Dynamic Field Definition
++++++++++++++++++++++++

By default, Titan uses Solr's https://cwiki.apache.org/confluence/display/solr/Dynamic+Fields[Dynamic Fields] feature to define the field types for all indexed keys. This requires no extra configuration when adding property keys to a mixed index backed by Solr and provides better performance than schemaless mode.

Titan assumes the following dynamic field tags are defined in the backing Solr collection's schema.xml file:

[source,xml]
----
<dynamicField name="*_i"    type="sint"     indexed="true"  stored="true"/>
<dynamicField name="*_s"    type="string"   indexed="true"  stored="true"/>
<dynamicField name="*_l"    type="slong"    indexed="true"  stored="true"/>
<dynamicField name="*_t"    type="text"     indexed="true"  stored="true"/>
<dynamicField name="*_b"    type="boolean"  indexed="true"  stored="true"/>
<dynamicField name="*_f"    type="sfloat"   indexed="true"  stored="true"/>
<dynamicField name="*_d"    type="sdouble"  indexed="true"  stored="true"/>
<dynamicField name="*_dt"   type="date"     indexed="true"  stored="true"/>
<dynamicField name="*_g"    type="geo"      indexed="true"  stored="true"/>
----

In Titan's default configuration, property key names do not have to end with the type-appropriate suffix to take advantage of Solr's dynamic field feature.  Titan generates the Solr field name from the property key name by encoding the property key definition's numeric identifier and the type-appropriate suffix.  This means that Titan uses synthetic field names with type-appropriate suffixes behind the scenes, regardless of the property key names defined and used by application code using Titan.  This field name mapping can be overridden through non-default configuration.  That's described in the next section. 

Manual Field Definition
+++++++++++++++++++++++

If the user would rather manually define the field types for each of the indexed fields in a collection, the configuration option `dyn-fields` needs to be disabled.  It is important that the field for each indexed property key is defined in the backing Solr schema before the property key is added to the index.

In this scenario, it is advisable to enable explicit property key name to field mapping in order to fix the field names for their explicit definition. This can be achieved in one of two ways:

. Configuring the name of the field by providing a `mapped-name` parameter when adding the property key to the index. See <<index-local-field-mapping>> for more information.
. By enabling the `map-name` configuration option for the Solr index which will use the property key name as the field name in Solr. See <<index-global-field-mapping>> for more information.

Schemaless Mode
+++++++++++++++

Titan can also interact with a SolrCloud cluster that is configured for https://cwiki.apache.org/confluence/display/solr/Schemaless+Mode[schemaless mode]. In this scenario, the configuration option `dyn-fields` should be disabled since Solr will infer the field type from the values and not the field name.

Note, however, that schemaless mode is recommended only for prototyping and initial application development and NOT recommended for production use. 

Troubleshooting
~~~~~~~~~~~~~~~

Collection Does Not Exist
^^^^^^^^^^^^^^^^^^^^^^^^^

The collection (and all of the required configuration files) must be initialized before a defined index can use the collection.

Connection Problems
^^^^^^^^^^^^^^^^^^^

Irrespective of the operation mode, a Solr instance or a cluster of Solr instances must be running and accessible from the Titan instance(s) in order for Titan to use Solr as an indexing backend. Check that the Solr cluster is running correctly and that it is visible and accessible over the network (or locally) from the Titan instances.


JTS ClassNotFoundException with Geo Data
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Solr relies on Spatial4j for geo processing.  Spatial4j declares an optional dependency on JTS ("JTS Topology Suite").  JTS is required for some geo field definition and query functionality.  If the JTS jar is not on the Solr daemon's classpath and a field in schema.xml uses a geo type, then Solr may throw a ClassNotFoundException on one of the missing JTS classes.  This typically appears when invoking `CREATE` in the https://wiki.apache.org/solr/CoreAdmin[Solr CoreAdmin API].  The exception appears in slightly different formats on the client and server sides, although the root cause is identical.

Here's a representative example from a Solr server log:

[source,text]
----
ERROR [http-8983-exec-5] 2014-10-07 02:54:06,665 SolrCoreResourceManager.java (line 344) com/vividsolutions/jts/geom/Geometry
java.lang.NoClassDefFoundError: com/vividsolutions/jts/geom/Geometry
        at com.spatial4j.core.context.jts.JtsSpatialContextFactory.newSpatialContext(JtsSpatialContextFactory.java:30)
        at com.spatial4j.core.context.SpatialContextFactory.makeSpatialContext(SpatialContextFactory.java:83)
        at org.apache.solr.schema.AbstractSpatialFieldType.init(AbstractSpatialFieldType.java:95)
        at org.apache.solr.schema.AbstractSpatialPrefixTreeFieldType.init(AbstractSpatialPrefixTreeFieldType.java:43)
        at org.apache.solr.schema.SpatialRecursivePrefixTreeFieldType.init(SpatialRecursivePrefixTreeFieldType.java:37)
        at org.apache.solr.schema.FieldType.setArgs(FieldType.java:164)
        at org.apache.solr.schema.FieldTypePluginLoader.init(FieldTypePluginLoader.java:141)
        at org.apache.solr.schema.FieldTypePluginLoader.init(FieldTypePluginLoader.java:43)
        at org.apache.solr.util.plugin.AbstractPluginLoader.load(AbstractPluginLoader.java:190)
        at org.apache.solr.schema.IndexSchema.readSchema(IndexSchema.java:470)
        at com.datastax.bdp.search.solr.CassandraIndexSchema.readSchema(CassandraIndexSchema.java:72)
        at org.apache.solr.schema.IndexSchema.<init>(IndexSchema.java:168)
        at com.datastax.bdp.search.solr.CassandraIndexSchema.<init>(CassandraIndexSchema.java:54)
        at com.datastax.bdp.search.solr.core.CassandraCoreContainer.create(CassandraCoreContainer.java:210)
        at com.datastax.bdp.search.solr.core.SolrCoreResourceManager.createCore(SolrCoreResourceManager.java:256)
        at com.datastax.bdp.search.solr.handler.admin.CassandraCoreAdminHandler.handleCreateAction(CassandraCoreAdminHandler.java:117)
        ...
----

Here's what normally appears in the output of the client that issued the associated `CREATE` command to the CoreAdmin API:

[source,text]
----
org.apache.solr.common.SolrException: com/vividsolutions/jts/geom/Geometry
        at com.datastax.bdp.search.solr.core.SolrCoreResourceManager.createCore(SolrCoreResourceManager.java:345)
        at com.datastax.bdp.search.solr.handler.admin.CassandraCoreAdminHandler.handleCreateAction(CassandraCoreAdminHandler.java:117)
        at org.apache.solr.handler.admin.CoreAdminHandler.handleRequestBody(CoreAdminHandler.java:152)
        ...
----

This is resolved by adding the JTS jar to the classpath of the Solr server.

To determine the ideal JTS version, first check the version of Spatial4j in use by the Solr cluster, then determine the version of JTS against which that Spatial4j version was compiled.  Spatial4j declares its target JTS version in the http://search.maven.org/#search|gav|1|g%3A%22com.spatial4j%22%20AND%20a%3A%22spatial4j%22[pom for the `com.spatial4j:spatial4j` artifact].

Advanced Solr Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~

DSE Search
^^^^^^^^^^

tbw

Hadoop Search
^^^^^^^^^^^^^

tbw
