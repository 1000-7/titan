<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../public/css/gollum.css" media="all">
  <link rel="stylesheet" type="text/css" href="../public/css/editor.css" media="all">
  <link rel="stylesheet" type="text/css" href="../public/css/dialog.css" media="all">
  <link rel="stylesheet" type="text/css" href="../public/css/template.css" media="all">
  
  <!--[if IE 7]>
  <link rel="stylesheet" type="text/css" href="../public/css/ie7.css" media="all">
  <![endif]-->
  
  <script type="text/javascript" src="../public/css/jquery.js"></script>
  <script type="text/javascript" src="../public/css/gollum.js"></script>
  <script type="text/javascript" src="../public/css/gollum.dialog.js"></script>
  <script type="text/javascript" src="../public/css/gollum.placeholder.js"></script>
  
  <script type="text/javascript" 
    src="../public/css/editor/gollum.editor.js"></script>
  <title>Transaction Handling</title>
</head>
<body>

<div id="wiki-wrapper" class="page">
<div id="head"><h3><a href="Home.html">Aurelius Titan 0.2</a></h3>
  <h1>Transaction Handling</h1>
  <ul class="actions">
    <li class="minibutton"><a href="/pages"
      class="action-all-pages">All Pages</a></li>
    <li class="minibutton" class="jaws">
      <a href="#" id="minibutton-new-page">New Page</a></li>
    <li class="minibutton"><a href="/edit/Transaction-Handling"
       class="action-edit-page">Edit Page</a></li>
    <li class="minibutton"><a href="/history/Transaction-Handling"
       class="action-page-history">Page History</a></li>
  </ul>
  <div id="searchbar">
    <form action="/search" method="get" id="search-form">
    <div id="searchbar-fauxtext">
      <input type="text" name="q" id="search-query" value="Search&hellip;" autocomplete="off">
      <a href="#" id="search-submit" title="Search this wiki">
        <span>Search</span>
      </a>
    </div>
    </form>
  </div></div>
<div id="wiki-content">
  <div class="wrap">
  <div id="wiki-body" class="gollum-textile-content">
    <div id="template">
      <p>Every graph operation in Titan occurs within the context of a transaction. According to the Blueprints&#x2019; specification, each thread opens its own transaction against the graph database with the first operation (i.e. retrieval or mutation) on the graph.</p>
<pre><code>TitanGraph g = TitanFactory.open("/tmp/titan");
Vertex juno = g.addVertex(null); //Automatically opens a new transaction
juno.setProperty("name", "juno");
g.stopTransaction(Conclusion.SUCCESS); //Commits transaction</code></pre>
<p>In this example, a local Titan graph database is opened. Adding the vertex &#x201C;juno&#x201D; is the first operation (in this thread) which automatically opens a new transaction. All subsequent operations occur in the context of that same transaction until the transaction is explicitly stopped or the graph database <code>shutdown()</code> which stops all currently running transactions successfully.</p>
<h2>Transactional Scope</h2>
<p>All graph elements (vertices, edges, and types) are only available in the transactional scope in which they were originally created. After a transaction is stopped, all its associated elements become unavailable and can no longer be accessed. For example, after creating the vertex &#x201C;juno&#x201D; and stopping the transaction in the code snippet above, the &#x201C;juno&#x201D; vertex becomes unavailable and accessing it would result in an exception. The transactional scope is strictly enforced to avoid accessing &#x201C;stale&#x201D; elements. To illustrate this point, assume a multi-user environment for the code example above. After stopping the transaction, all (potentially) held locks on the &#x201C;juno&#x201D; vertex are released and another transaction running in a different thread (or on another machine) might mutate the vertex. The vertex reference &#x201C;juno&#x201D; would thus be stale and further access to the vertex could lead to inconsistencies.<br />
To re-active the &#x201C;juno&#x201D; vertex we need to refresh it in the currently running transaction as shown in the following example:</p>
<pre><code>TitanGraph g = TitanFactory.open("/tmp/titan");
Vertex juno = g.addVertex(null); //Automatically opens a new transaction
juno.setProperty("name", "juno");
g.stopTransaction(Conclusion.SUCCESS); //Commits transaction
Vertex jupiter = g.addVertex(null); //Automatically opens another transaction
jupiter.setProperty("name", "jupiter");
juno = g.getVertex(juno);
Edge married = g.addEdge(null, juno, jupiter, "married");</code></pre>
<h2>Transaction Failures</h2>
<p>When committing a transaction, Titan will attempt to persist all changes to the storage backend. This might not always be successful due to IO exceptions, network errors, machine crashes or resource unavailability. Hence, transactions can fail. In fact, transactions <strong>will eventually fail</strong> in sufficiently large systems. Therefore, we highly recommend that your code expects and accommodates such failures.</p>
<pre><code>try {
    if (g.getVertices("name",name).iterator().hasNext())
        throw new IllegalArgumentException("Username already taken: " + name);
    Vertex user = g.addVertex(null);
    user.setProperty("name", name);
    g.stopTransaction(Conclusion.SUCCESS);
} catch (TitanException e) {
    //Recover, retry, or return error message
}</code></pre>
<p>The example above demonstrates a simplified user signup implementation where <code>name</code> is the name of the user who wishes to register. First, it is checked whether a user with that name already exists. If not, a new user vertex is created and the name assigned. Finally, the transaction is committed.</p>
<p>If the transaction fails, a <code>TitanException</code> is thrown. There are a variety of reasons why a transaction may fail. Titan differentiates between <em>potentially temporary</em> and <em>permanent</em> failures.</p>
<p>Potentially temporary failures are those related to resource unavailability and IO hickups (e.g. network timeouts). Titan automatically tries to recover from temporary failures by retrying to persist the transactional state after some delay. The number of retry attempts and the retry delay can be configured through the <a class="internal present" href="Graph-Configuration.html">Titan graph configuration</a>.</p>
<p>Permanent failures can be caused by complete connection loss, hardware failure or lock contention. To understand the cause of lock contention, consider the signup example above and suppose a user tries to signup with username &#x201C;juno&#x201D;. That username may still be available at the beginning of the transaction but by the time the transaction is committed, another user might have concurrently registered with &#x201C;juno&#x201D; as well and that transaction holds the lock on the username therefore causing the other transaction to fail. It some cases one can recover from a lock contention failure by re-running the entire transaction.</p>
<h2>Next Steps</h2>
<ul><li>Read more about <a href="https://github.com/tinkerpop/blueprints/wiki/Graph-Transactions">Blueprints Transactions</a></li>
	<li>Learn how to speed up transactions with <a class="internal present" href="Multi-Threaded-Transactions.html">multiple threads</a></li>
</ul>
    </div>
  </div>
  </div>

</div>
<div id="footer">
  <p id="last-edit">Last edited by <b>okram</b>, 2012-12-24 03:56:13</p>
</div>
</div>

<script type="text/javascript" src="../public/css/MathJax/MathJax.js"></script>


</body>
</html>
