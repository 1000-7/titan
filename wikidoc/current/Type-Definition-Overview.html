<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../public/css/gollum.css" media="all">
  <link rel="stylesheet" type="text/css" href="../public/css/editor.css" media="all">
  <link rel="stylesheet" type="text/css" href="../public/css/dialog.css" media="all">
  <link rel="stylesheet" type="text/css" href="../public/css/template.css" media="all">
  
  <!--[if IE 7]>
  <link rel="stylesheet" type="text/css" href="../public/css/ie7.css" media="all">
  <![endif]-->
  
  <script type="text/javascript" src="../public/css/jquery.js"></script>
  <script type="text/javascript" src="../public/css/gollum.js"></script>
  <script type="text/javascript" src="../public/css/gollum.dialog.js"></script>
  <script type="text/javascript" src="../public/css/gollum.placeholder.js"></script>
  
  <script type="text/javascript" 
    src="../public/css/editor/gollum.editor.js"></script>
  <title>Type Definition Overview</title>
</head>
<body>

<div id="wiki-wrapper" class="page">
<div id="head"><h3><a href="Home.html">Aurelius Titan 0.1.0</a></h3>
  <h1>Type Definition Overview</h1>
  <ul class="actions">
    <li class="minibutton"><a href="/pages"
      class="action-all-pages">All Pages</a></li>
    <li class="minibutton" class="jaws">
      <a href="#" id="minibutton-new-page">New Page</a></li>
    <li class="minibutton"><a href="/edit/Type-Definition-Overview"
       class="action-edit-page">Edit Page</a></li>
    <li class="minibutton"><a href="/history/Type-Definition-Overview"
       class="action-page-history">Page History</a></li>
  </ul>
  <div id="searchbar">
    <form action="/search" method="get" id="search-form">
    <div id="searchbar-fauxtext">
      <input type="text" name="q" id="search-query" value="Search&hellip;" autocomplete="off">
      <a href="#" id="search-submit" title="Search this wiki">
        <span>Search</span>
      </a>
    </div>
    </form>
  </div></div>
<div id="wiki-content">
  <div class="wrap">
  <div id="wiki-body" class="gollum-textile-content">
    <div id="template">
      <p><span class="float-left"><span><img src="https://github.com/thinkaurelius/titan/raw/master/doc/images/titan-configuration.png" width="200px" /></span></span></p>
<p>In Titan, edge lables and property keys are <strong>types</strong> which can be individually configured to provide data verification, better storage efficiency, and higher performance. Types are uniquely identified by their name and are themselves vertices in the graph. Type vertices can be retrieved by their name.</p>
<pre><code>TitanGraph graph = ...
TitanType name = graph.getType("name");</code></pre>
<p>A <code>TitanType</code> is either a <code>TitanLabel</code> (for edges) or a <code>TitanKey</code> (for properties) which means either <code>TitanType.isEdgeLabel()</code> or <code>TitanType.isPropertyKey()</code> is true and we can cast it to the particular subtype.</p>
<pre><code>TitanType name = graph.getType("name");
if (name.isPropertyKey()) 
  TitanKey namekey = (TitanKey)name;
else 
  TitanLabel namelabel = (TitanLabel)name;</code></pre>
<p>Most methods in Titan are overloaded to allow either the type name or the type object as argument.</p>
<h2>Type Creation</h2>
<p>Labels and keys are automatically created when their name is first used. However, types can also be created and configured explicitly by the user through a <code>TypeMaker</code> instance returned by <code>TitanGraph.makeType()</code>. The <code>TypeMaker</code> provides the following type configuration options.</p>
<table><tr><th>Method </th>
		<th>Description </th>
		<th>Applies to </th>
		<th>Default </th>
		<th>Inspection Method </th>
	</tr><tr><td> <code>name(String)</code> </td>
		<td> Defines the name of the type. <strong>Must be unique across all types. Required.</strong> </td>
		<td> Label and Key </td>
		<td> &#x2013; </td>
		<td> <code>TitanType.getName()</code> </td>
	</tr><tr><td> <code>functional()</code> </td>
		<td> Configures the type to be functional and acquires locks to ensure consistency </td>
		<td> Label and Key </td>
		<td> not functional </td>
		<td> <code>TitanType.isFunctional()</code> </td>
	</tr><tr><td> <code>functional(boolean)</code> </td>
		<td> Configures the type to be functional. The boolean argument configures whether locks should be acquired when modifying an edge or property of this type </td>
		<td> Label and Key </td>
		<td> not functional </td>
		<td> <code>TitanType.isFunctional()</code> </td>
	</tr><tr><td> <code>simple()</code> </td>
		<td> Configures the type to be simple, which means that the edges of this type do not allow properties to be set and invoking <code>setProperty()</code> on such an edge will throw an exception. Simple edges can be stored and retrieved more efficiently. </td>
		<td> Label </td>
		<td> not simple </td>
		<td> <code>TitanType.isSimple()</code> </td>
	</tr><tr><td> <code>group(TypeGroup)</code> </td>
		<td> Assigns the type to the specified <code>TypeGroup</code> which allows grouping of edges for efficient retrieval. </td>
		<td> Label and Key </td>
		<td> <code>DEFAULT_GROUP</code> </td>
		<td> <code>TitanType.getGroup()</code> </td>
	</tr><tr><td> <code>directed()</code> </td>
		<td> Configures the type for directed edges, i.e. from out-vertex to in-vertex. </td>
		<td> Label </td>
		<td> directed </td>
		<td> <code>TitanLabel.isDirected()</code> </td>
	</tr><tr><td> <code>undirected()</code> </td>
		<td> Configures the type for undirected edges, i.e. there is no order between out- and in-vertices </td>
		<td> Label </td>
		<td> directed </td>
		<td> <code>TitanLabel.isUndirected()</code> </td>
	</tr><tr><td> <code>unidirected()</code> </td>
		<td> Configures the type for unidirected edges, i.e. edges that can only be traversed from out-vertex to in-vertex. Unidirected edges can be stored more efficiently </td>
		<td> Label </td>
		<td> directed </td>
		<td> <code>TitanLabel.isUnidirected()</code> </td>
	</tr><tr><td> <code>unique()</code> </td>
		<td> Configures the key to be unique which means that each property value for this key is uniquely assigned to one vertex. For example, <em>name</em> is unique, because each name uniquely identifies one god. Acquires locks to ensure uniqueness and requires the key to be indexed. </td>
		<td> Key </td>
		<td> not unique </td>
		<td> <code>TitanKey.isUnique()</code> </td>
	</tr><tr><td> <code>indexed()</code> </td>
		<td> Configures the key to be indexed which allows vertices to be retrieved by key-value pair via <code>getVertices(key,value)</code> </td>
		<td> Key </td>
		<td> not indexed </td>
		<td> <code>TitanKey.hasIndex()</code> </td>
	</tr><tr><td> <code>dataType(Class)</code> </td>
		<td> Configures the data type of this key. Property instances for this key will only accept attribute values that are instances of this class. Every property key must have its data type configured. Setting the data type to Object.class allows any type of attribute but comes at the expense of longer serialization because class information<br />
is stored with the attribute value. See <a href="Graph-Configuration">Graph Configuration</a> for more information on how to define custom attribute data types. </td>
		<td> Key </td>
		<td> &#x2013; </td>
		<td> <code>TitanKey.getDataType()</code> </td>
	</tr><tr><td> <code>primaryKey(TitanType...)</code> </td>
		<td> Configures the composite primary key for this type. </td>
		<td> Label </td>
		<td> empty </td>
		<td> &#x2013; </td>
	</tr><tr><td> <code>signature(TitanType...)</code> </td>
		<td> Configures the signature of this type. </td>
		<td> Label </td>
		<td> empty </td>
		<td> &#x2013; </td>
	</tr><tr><td> <code>makeEdgeLabel()</code> </td>
		<td> Creates an edge label according to the configuration of this TypeMaker. </td>
		<td> Label </td>
		<td> &#x2013; </td>
		<td> &#x2013; </td>
	</tr><tr><td> <code>makePropertyKey()</code> </td>
		<td> Creates a property key according to the configuration of this TypeMaker. </td>
		<td> Key </td>
		<td> &#x2013; </td>
		<td> &#x2013; </td>
	</tr></table><p>Below are some examples of creating labels and keys using <code>TypeMaker</code>.</p>
<h3>Functional Types</h3>
<p>A type is functional, if there is at most one edge or property of this type per vertex. Specifically, this means:</p>
<ul><li>A property key is functional, if a vertex has at most one value associated with the key. <em>name</em> is an example of a functional property key since each god has one name.</li>
	<li>An edge lable is functional, if a vertex has at most one outgoing edge for that label. <em>father</em> is an exmaple of a functional edge label, since each god has at most one father.</li>
</ul><p>Since edges and properties of functional labels and keys must be unique per vertex, inconsistencies could arise when two <code>TitanGraph</code> instances try to update the same functional edge or property concurrently, since one may overwrite the change of the other. To avoid such inconsistencies, Titan will acquire locks on functional edges and properties by default. Acquiring locks, however, can be very expensive depending on the storage backend. In cases where concurrent modifications can be excluded or blind overwrites are acceptable, a functional <code>TitanType</code> can be configured to <em>not</em> acquire locks using <code>TypeMaker.functional(false)</code>. This configuration options should be used with care and only if the extra performance gain is needed.</p>
<h3>Type Groups</h3>
<p>Titan allows types to be grouped and to retrieve all edges or properties for a type group. For example, in the graph of gods we have <em>father</em>, <em>mother</em>, and <em>brother</em> labels. If we want to retrieve all family members of a vertex, we could do</p>
<pre><code>v.getVertices(OUT,"father","mother","brother")</code></pre>
<p>However, this becomes cumbersome as more family labels like <em>sister</em>, <em>uncle</em>, etc are added. Moreover, each edge label requires and independent index retrieval. In the example above, the database index is accessed three times. Instead, a family type group can group all these labels together.</p>
<pre><code>TypeGroup family = TypeGroup.of(2,"family");
TitanLabel father = g.makeType().name("father").group(family).makeEdgeLabel();
TitanLabel mother = g.makeType().name("mother").group(family).makeEdgeLabel();
TitanLabel brother = g.makeType().name("brother").group(family).makeEdgeLabel();
// Load data...

TitanVertex jupiter = (TitanVertex)g.getVertices("name","jupiter").iterator().next();
jupiter.query().group(family).vertices();</code></pre>
<p>In this example, a <em>family</em> type group is defined with id 2. Type groups are uniquely identified by their id and <span class="caps">NOT</span> their name. That is, two type groups with the same id are considered equivalent. <code>TypeGroup.DEFAULT_GROUP</code> has id=1 and therefore custom type groups should use ids larger than 1. The maximum id is 126.<br />
Once the type group is defined, we assign the <em>father</em>, <em>mother</em>, and <em>brother</em> labels to this group. Now, all family members of Jupiter can be retrieved in one database operation by specifying the group via <code>TitanQuery.group()</code>.</p>
<h3>Primary Keys and Signatures</h3>
<p>Specifying the primary key of a labels allows edges with this label to be efficiently retrieved in the order of the key. Titan builds vertex-centric indexes for each label according to the primary key definition which can significantly speed up queries.</p>
<pre><code>TitanKey time = g.makeType().name("time").dataType(Integer.class).functional().makePropertyKey();
TitanLabel battled = g.makeType().name("battled").primaryKey(time).makeEdgeLabel();</code></pre>
<p>In this example, the functional property key time is defined with data type <code>Integer</code>. This property key is then used as the primary key for the <em>battled</em> edge label. Hence, <em>battled</em> edges will be sorted by time and battles that happened in a certain time range can be queried for more efficiently. Moreover, <em>battled</em> edges are stored more compactly on disk.</p>
<p>Note, that <code>TitanTypes</code> used in the primary key must be either functional property keys or functional, simple, unidirected edge lables.</p>
<p>If one is not interested in configuring the order of edges but only wants to benefit from the storage efficiencies introduced by primary keys, one can alternatively configure the signature of a label. Specifying the signature of a label tells the graph database to <em>expect</em> that edges with this label always have or are likely to have an incident property or unidirected edge of the type included in the signature. This allows the graph database to store such edges more compactly and retrieve them more quickly.</p>
<pre><code>TitanKey time = g.makeType().name("time").dataType(Integer.class).functional().makePropertyKey();
TitanLabel battled = g.makeType().name("battled").signature(time).makeEdgeLabel();</code></pre>
<p>This example is almost identical to the primary key example above with the only difference that <em>time</em> is configured to be part of the signature.</p>
<p>If a type is used in the primary key, it cannot be part of the signature.<br />
As before, <code>TitanTypes</code> used in the signature must be either functional property keys or functional, simple, unidirected edge lables.</p>
<h2>Default Type Creation</h2>
<p>Titan will create edge labels and property keys the first time they are referenced by name using a default configuration unless they have been previously configured using <code>TypeMaker</code> as discussed above.</p>
<p>By default, property keys are configured to be functional but non-locking with <code>Object.class</code> as the data type. Note, that it is more efficient to define an appropriate data type via <code>TypeMaker</code>. Hence, property keys don&#x2019;t have an index by default. To create an indexed key with this default configuration, invoke <code>Graph.createKeyIndex("name",Vertex.class)</code> before the property key is being used.</p>
<p>Edge labels are created according to the default configuration shown in the table above.</p>
<p>The default type creation behavior is configured via the <code>autotype</code> configuration option. By default, it uses the configuration value <code>blueprints</code> which creates types automatically as described above. To disable automatic type creation, set <code>autotype=none</code>. Setting the option to none requires that all types are explicitly created and will throw an <code>IllegalArgumentException</code> each time a non-existent type is referenced which is useful to avoid type name typos.</p>
    </div>
  </div>
  </div>

</div>
<div id="footer">
  <p id="last-edit">Last edited by <b>okram</b>, 2012-09-06 19:50:26</p>
</div>
</div>

<script type="text/javascript" src="../public/css/MathJax/MathJax.js"></script>


</body>
</html>
